main.py
import os

from dotenv import load_dotenv

from custom_mcp import CustomMCP

from tools import WeatherTool, DateTool

import google.generativeai as genai

load_dotenv()

tools = [

    WeatherTool(api_key=os.getenv("OPENWEATHERMAP_API_KEY")),

    DateTool()

]

genai.configure(api_key=os.getenv("GEMINI_API_KEY"))

model = genai.GenerativeModel("gemini-2.5-flash-lite")

assistant = CustomMCP(model=model, tools=tools)

def main():

    print("ðŸ¤– Simple AI Assistant")

    print("Ask me about weather or time!")

    print("Type 'exit' to quit.\n")

    while True:

        user_input = input("You: ")

        if user_input.lower() in ["exit", "quit"]:

            print("Goodbye")

            break

        if not user_input.strip():

            continue

        response = assistant.chat(user_input)

        print(f"Assistant: {response}\n")

if __name__ == "__main__":

    main()


custom_mcp.py
from google.generativeai.types import GenerationConfig

class CustomMCP:

    def __init__(self, model, tools: list):

        self.model = model

        self.tools = {tool.name: tool for tool in tools}

        self.tool_schemas = [{

            "function_declarations": [{

                "name": tool.name,

                "description": tool.description,

                "parameters": {

                    "type": "object",

                    "properties": tool.get_schema()["parameters"]["properties"],

                    "required": tool.get_schema()["parameters"].get("required", [])

                }

            }]

        } for tool in tools]

    def _execute_function_call(self, function_call) -> dict:

        function_name = function_call.name

        args = function_call.args

        if function_name not in self.tools:

            return {"status": "error", "message": f"Unknown function '{function_name}'"}

        tool = self.tools[function_name]

        try:

            return tool.execute(params=dict(args))

        except Exception as e:

            return {"status": "error", "message": f"Failed to execute tool: {str(e)}"}

    def chat(self, user_input: str) -> str:

        try:

            conversation = [{"role": "user", "parts": [{"text": user_input}]}]

            response = self.model.generate_content(

                conversation,

                generation_config=GenerationConfig(temperature=0.7),

                tools=self.tool_schemas

            )

            if response.candidates and response.candidates[0].content.parts:

                parts = response.candidates[0].content.parts

                function_responses = []

                for part in parts:

                    if hasattr(part, 'function_call') and part.function_call:

                        function_response = self._execute_function_call(part.function_call)

                        function_responses.append({

                            "name": part.function_call.name,

                            "response": function_response

                        })

                if function_responses:

                    conversation.append(response.candidates[0].content)

                    conversation.append({

                        "role": "function",

                        "parts": [{"function_response": resp} for resp in function_responses]

                    })

                    response = self.model.generate_content(

                        conversation,

                        generation_config=GenerationConfig(temperature=0.7),

                        tools=self.tool_schemas

                    )

            final_text = "".join(

                part.text for part in response.candidates[0].content.parts if hasattr(part, 'text')

            )

            return final_text.strip() if final_text else "I couldn't process your request."

        except Exception as e:

            return f"Sorry, an error occurred: {e}"

tools.py
import requests

from datetime import datetime

class Tool:

    def __init__(self, name: str, description: str):

        self.name = name

        self.description = description

    def execute(self, params: dict) -> dict:

        raise NotImplementedError("Subclasses must implement execute method")

    def get_schema(self) -> dict:

        raise NotImplementedError("Subclasses must implement get_schema method")

class WeatherTool(Tool):

    def __init__(self, api_key: str):

        super().__init__("weather", "Get weather for any city")

        self.api_key = api_key

        self.base_url = "https://api.openweathermap.org/data/2.5/weather"

    def execute(self, params: dict) -> dict:

        city = params.get("city", "Bengaluru")

        try:

            response = requests.get(self.base_url, params={

                "q": city,

                "appid": self.api_key,

                "units": "metric"

            })

            response.raise_for_status()

            data = response.json()

            return {

                "status": "success",

                "city": data.get("name"),

                "temperature": f"{data.get('main', {}).get('temp', 0):.1f}Â°C",

                "weather": data.get("weather", [{}])[0].get("description", "Unknown")

            }

        except Exception as e:

            return {"status": "error", "message": f"Weather error: {e}"}

    def get_schema(self) -> dict:

        return {

            "parameters": {

                "type": "object",

                "properties": {

                    "city": {"type": "string", "description": "City name"}

                }

            }

        }

class DateTool(Tool):

    def __init__(self):

        super().__init__("date", "Get current date and time")

    def execute(self, params: dict) -> dict:

        now = datetime.now()

        return {

            "status": "success",

            "full_date": now.strftime("%A, %B %d, %Y"),

            "time": now.strftime("%I:%M %p"),

            "day": now.strftime("%A"),

            "year": now.strftime("%Y")

        }

    def get_schema(self) -> dict:

        return {

            "parameters": {

                "type": "object",

                "properties": {}

            }

        }

